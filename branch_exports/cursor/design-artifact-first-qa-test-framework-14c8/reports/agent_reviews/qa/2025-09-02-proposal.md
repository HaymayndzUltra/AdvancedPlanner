### QA & Test Framework — Artifact-First Design Proposal (2025-09-02)

### 1) Executive Summary
This module specifies an artifact-first QA & Test framework: all interop happens via files (YAML/MD/JSON), never by hidden APIs or state. Work progresses through the event lifecycle: PLANNED → READY_FOR_HANDOFF → PACKAGED → EXECUTED → VALIDATED → IMPROVE. Quality is enforced by gates for schema_lint, cross_stream_consistency, and parity/coverage. Handoffs are immutable and sealed via a manifest carrying checksums, snapshot_rev, and rulebook_hash. A governance overlay mandates governance.tags[] for every artifact; Critical=0 is required before promotion. Exceptions are explicit records {rule_id, approver, expiry, rationale}. A metrics spine defines KPIs (name, formula, source) and emits a digest each cycle to drive continuous improvement.

### 2) Deliverables (file-based artifacts)
- **test_matrix.yaml**
  - Scope: test streams and cases across unit, integration, e2e, property-based.
  - Content: `version`, `governance.tags[]`, `streams[]`, `test_cases[]` with `id`, `title`, `type`, `priority`, `owner`, `preconditions`, `steps`, `expected`, `data_refs[]`, `environments[]`, `risk_id`, `coverage_targets` (line/branch/path), `parity_targets` (browser/os/region/device), `links.requirements[]`.
  - Rules: must pass schema_lint; ids globally unique; each test ties to at least one requirement or documented rationale.
- **traceability_map.md**
  - Purpose: bidirectional mapping among requirements, risks, controls, and tests.
  - Sections: Requirements → Tests, Risks → Controls/Tests, Tests → Evidence; entries include coverage/parity notes.
- **evidence_index.md**
  - Purpose: canonical catalog of execution evidence per cycle.
  - Content: for each `test_id`, evidence file paths/URIs, checksums, size, created_at, retention class, and governance.tags[].
- **handoff_manifest.yaml**
  - Purpose: immutable manifest for sealed handoffs.
  - Content: `bundle_id`, `snapshot_rev` (e.g., git commit), `rulebook_hash`, `artifacts[]` with `path`, `type`, `sha256`, `size`, `governance.tags[]`, `gates` summary, `exceptions[]`, and optional `signatures[]`.
- **digest.md**
  - Purpose: cycle summary of KPIs, gate outcomes, exceptions, risks, actions, and sign-offs.

### 3) Events & Gates
- **PLANNED**
  - Inputs: requirements, risks, rulebook.
  - Outputs: initial `test_matrix.yaml`, draft `traceability_map.md`.
  - Gates: schema_lint (test_matrix), governance tags present (Owner, RiskLevel, Critical), initial coverage/parity targets sketched.
- **READY_FOR_HANDOFF**
  - Inputs: finalized plan artifacts with governance.tags[].
  - Outputs: candidate bundle (pre-seal).
  - Gates: cross_stream_consistency (requirements ↔ tests ↔ risks), parity/coverage targets concretized, Critical=0 or explicit exceptions.
- **PACKAGED**
  - Inputs: artifacts + computed checksums.
  - Outputs: sealed bundle with `handoff_manifest.yaml` and rulebook_hash.
  - Gates: manifest integrity (complete listing + hashes), deterministic packaging, optional signature verification.
- **EXECUTED**
  - Inputs: sealed bundle.
  - Outputs: evidence files + `evidence_index.md` updates.
  - Gates: parity/coverage achieved vs targets; flakiness within budget; execution completeness.
- **VALIDATED**
  - Inputs: evidence, computed KPIs, exceptions.
  - Outputs: validated decision + `digest.md`.
  - Gates: cross_stream_consistency proven via traceability; Critical=0 enforced; exceptions time-bounded and approved.
- **IMPROVE**
  - Inputs: digest insights, defects, escapes.
  - Outputs: rule updates, new/refactored tests, risk re-assessment, next-cycle targets.
  - Gates: regression guardrail (no reduction in coverage/parity without exception).

### 4) Workflow (artifact-first)
1. Establish rulebook and governance taxonomy; assign owners.
2. Author `test_matrix.yaml` and `traceability_map.md`; run schema_lint.
3. Define coverage/parity targets per stream; run cross_stream_consistency.
4. Attach governance.tags[]; ensure Critical=0 or record exceptions.
5. Package artifacts; compute checksums and rulebook_hash; produce `handoff_manifest.yaml`; seal.
6. Execute from sealed bundle; generate and index evidence.
7. Validate with KPIs; decide promotion; publish `digest.md`.
8. Improve using digest actions; update rulebook/targets.

RACI can be embedded via governance.tags[] (e.g., `Owner:`, `Approver:`, `RiskChampion:`) and audited at gates.

### 5) Handoff & Sealing
- The sealed bundle is immutable; all references must resolve via `handoff_manifest.yaml`.
- Manifest includes `sha256` and `size` for each artifact, `snapshot_rev` of repos, and `rulebook_hash` to ensure reproducibility.
- Optionally include `signatures[]` (signer, algorithm, signature) for cryptographic attestation.

### 6) Governance Integration
- Every artifact includes `governance.tags[]` (e.g., `Product`, `RiskLevel`, `PII`, `Retention`, `Owner`).
- Promotion requires Critical=0. If not achievable, exceptions must be explicit objects: `{rule_id, approver, expiry, rationale}` and are logged in both manifest and digest.
- Rulebook changes are controlled and hashed; `rulebook_hash` is recorded in manifests for auditability.

### 7) Metrics & Digest
KPI spine (each has `name`, `formula`, `source`):
- Gate Pass Rate = passed_gates / total_gates; source: gate logs + manifest.
- Coverage Target Attainment = achieved_coverage / target_coverage across streams; source: `test_matrix.yaml` + execution reports.
- Parity Target Attainment = achieved_parity / target_parity; source: `test_matrix.yaml` + evidence.
- Exception Debt = active_exceptions count and age; source: exceptions ledger/digest.
- Time-to-Validate = VALIDATED_time − PACKAGED_time; source: event timestamps.
- Bundle Integrity Rate = sealed_artifacts_hashed / expected_artifacts; source: manifest.
- Defect Escape Rate = escaped_defects / total_defects (rolling N cycles); source: incidents.

The `digest.md` summarizes KPI values, gate outcomes, exceptions `{rule_id, approver, expiry, rationale}`, top risks, actions, and sign-offs for the cycle.

### 8) Acceptance Criteria
- Artifact-first interop only (YAML/MD/JSON).
- Lifecycle events and gates enforced at each transition.
- Immutable handoff manifests include checksums, snapshot_rev, and rulebook_hash.
- Governance overlay on all artifacts; Critical=0 before promotion or approved exceptions.
- KPI spine implemented; `digest.md` produced each cycle.
- End-to-end traceability verifiable across requirements, risks, tests, and evidence.

### 9) Risks & Mitigations
- Gate friction → Provide templates, automation, and a clear exception path.
- Evidence sprawl → Maintain `evidence_index.md` with checksums and retention tags.
- Flakiness → Track stability KPI; quarantine tests with expiry; do not count toward parity/coverage.
- Rule drift → Hash rulebook; enforce change control and review.
- Partial adoption → Block promotion via cross_stream_consistency gate.

### 10) Timeline & Next Steps
- Week 1: Finalize rulebook and governance taxonomy; publish templates.
- Week 2: Implement schema_lint and cross_stream_consistency; pilot one stream.
- Week 3: Add packaging/sealing and manifest generation; enable KPI calculations.
- Week 4: Run full cycle; publish first `digest.md`; plan IMPROVE actions.

Immediate next steps: confirm owners, publish templates for `test_matrix.yaml`, `traceability_map.md`, `evidence_index.md`, `handoff_manifest.yaml`, then schedule the PLANNED → READY_FOR_HANDOFF review.