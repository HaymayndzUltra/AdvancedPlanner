```json
{
  "contract_id": "release-mgmt",
  "contract_version": "1.0.0",
  "snapshot_rev": "20250902.0",
  "rulebook_hash": "sha256:rulebook-v1",
  "created_at": "2025-09-02T00:00:00Z"
}
```

### Release Management Framework — Design Doc

#### 1) Executive Summary (what/why/goals)
- **What**: A release management framework that drives artifact-first, append-only release flow with sealed handoffs, cross-stream traceability, and governed promotion decisions.
- **Why**: Ensure every release item is mapped across FE/BE/QA, rollback-ready, policy-compliant, and reproducible via immutable manifests and consistent snapshots.
- **Goals**:
  - **G1**: 100% release items mapped FE↔BE↔QA with rollback_ref present.
  - **G2**: Immutable handoff manifest with consistent `snapshot_rev` across artifacts.
  - **G3**: Critical=0 before promotion or documented and approved exceptions.
  - **G4**: Automated gates (schema_lint, cross_stream_consistency, parity/coverage) with minimal HITL.

#### 2) Deliverables (exact files: path + fields (MUST/SHOULD) + refs)
- `/frameworks/release-mgmt/artifacts/release_plan.yaml`
  - **header**: `{contract_id, contract_version, snapshot_rev, rulebook_hash, created_at}` MUST
  - **release**:
    - `release_id` (string) MUST
    - `release_window.start` (ISO8601) SHOULD
    - `release_window.end` (ISO8601) SHOULD
    - `owners[]` (name/email) SHOULD
  - **items[]`**:
    - `release_item_id` (string) MUST
    - `story_ref[]` (string) MUST  // FE planning link(s)
    - `endpoint_ref[]` (string) SHOULD  // BE contract/endpoint(s)
    - `test_ref[]` (string) SHOULD  // QA contract/e2e id(s)
    - `change_type` (feature|bugfix|hotfix|infra) MUST
    - `risk_level` (P0|P1|P2) MUST
    - `rollback_ref` (string path or runbook id) MUST
    - `target_envs[]` (dev|stage|prod) MUST
    - `dependencies[]` (release_item_id) SHOULD
    - `governance.tags[]` (e.g., auth, PII, license, SLA) SHOULD

- `/frameworks/release-mgmt/reports/cross_stream_map.md`
  - Table mapping: `story_ref ↔ endpoint_ref ↔ test_ref ↔ governance.tag(s) ↔ ui_component/token_ref ↔ rollback_ref`
  - Gaps section for missing mappings.

- `/frameworks/release-mgmt/manifests/handoff_manifest.yaml`
  - `release_id`, `framework_rev`
  - `artifacts[]`: `path`, `checksum`
  - `snapshot_rev`, `rulebook_hash`
  - `owners`, `timestamps`

- `/frameworks/release-mgmt/reports/policy_exceptions.md`
  - Entries `{rule_id, approver, expiry, rationale}`

- `/frameworks/release-mgmt/reports/release_notes.md`
  - Standardized sections: Summary, Items, Risks, Rollback, Links (refs to `story_ref`, `endpoint_ref`, `test_ref`)

- `/frameworks/release-mgmt/digests/YYYYMMDD-digest.md`
  - One-page digest: TL;DR, gates status, KPIs, actionable notes, go/no-go, snapshot/manifest refs

All files include the common artifact header.

#### 3) Events & Gates (produced/consumed; gate criteria; pass/fail)
- **Produced Events (append-only)**
  - `PLANNED(release, rev)`: initial `release_plan.yaml` exists and schema_lint PASS
  - `READY_FOR_HANDOFF(release, rev)`: all gates PASS; manifest drafted
  - `PACKAGED(release, rev)`: manifest sealed (immutable) with checksums
  - `EXECUTED(release, rev)`: deployment executed (links to evidence)
  - `VALIDATED(release, rev)`: post-release validation PASS
  - `IMPROVE(release, rev)`: retro captured; metrics digested

- **Consumed Events**
  - `PLANNED` from `planning-fe`, `planning-be`, `qa-test` to build mapping

- **Gates (fail-fast)**
  - `schema_lint`:
    - `release_plan.yaml` conforms; all item-level MUST present; header present in all artifacts
    - PASS/FAIL: binary
  - `cross_stream_consistency`:
    - Every `story_ref` exists in FE planning; every `endpoint_ref` exists in BE contracts/backlog; every `test_ref` exists in QA matrix
    - Governance tags align with governance registry (PII/auth/retention/license)
    - UI changes link to `ux component/token_ref` if applicable
    - PASS/FAIL: binary
  - `parity/coverage`:
    - `item_mapping_parity = mapped_items / total_items ≥ 0.95`
    - `critical_item_coverage = 1.0` for P0 items across FE↔BE↔QA
    - `rollback_coverage = items_with_rollback / total_items = 1.0`
    - PASS/FAIL: thresholds as above

#### 4) Workflow (inputs → process → outputs; where handoff happens)
1. Inputs: `planning/frontend/.../fe_task_breakdown.yaml`, `planning/backend/.../be_backlog.yaml`, `qa-test/artifacts/test_matrix.yaml`, governance registry.
2. Build `release_plan.yaml` with items and tags; compute cross-stream map; mark gaps.
3. Run gates in order: schema_lint → cross_stream_consistency → parity/coverage.
4. If all PASS: draft `handoff_manifest.yaml` (artifacts + checksums), emit `READY_FOR_HANDOFF`.
5. Seal manifest (immutable), emit `PACKAGED`.
6. Execute deployment; capture evidence; emit `EXECUTED`.
7. Validate post-release; publish digest; emit `VALIDATED` then `IMPROVE` with retro notes.

Handoff occurs between steps 4 and 5; sealing at step 5.

#### 5) Handoff & Sealing (manifest contents; when READY_FOR_HANDOFF; snapshot rule)
- **READY_FOR_HANDOFF** when: schema PASS, consistency PASS, parity/coverage PASS, evidence paths enumerated.
- **Manifest contents**: `release_id`, `framework_rev`, `artifacts[]` (path+checksum), `snapshot_rev`, `rulebook_hash`, `owners`, `timestamps`.
- **Snapshot rule**: Mixed `snapshot_rev` across any included artifact = BLOCK (no handoff).

#### 6) Governance Integration (tags you emit; exceptions format; Critical=0 rule)
- **Tags emitted**: `security`, `auth`, `PII`, `license`, `SLA`, `retention`, `regulatory`.
- **Exceptions**: `/frameworks/release-mgmt/reports/policy_exceptions.md` entries `{rule_id, approver, expiry, rationale}`.
- **Policy**: `Critical=0` required before release promotion; exceptions must be explicit and within expiry.

#### 7) Metrics & Digest (KPIs; digest contents/path)
- **KPIs (name, formula, source, window)**
  - `release_item_mapping_parity` = mapped_items / total_items (source: cross_stream_map.md) window: per cycle
  - `rollback_coverage` = items_with_rollback / total_items (source: release_plan.yaml) window: per cycle
  - `critical_test_coverage` = critical_items_with_test / critical_items (source: qa-test matrix) window: per cycle
  - `change_failure_rate` = failed_releases / total_releases (source: ops logs) window: trailing 4 cycles
  - `mean_time_to_restore_mins` = sum(restore_durations) / incidents (source: incident tracker) window: trailing 4 cycles
  - `gate_pass_rate` = passed_gates / total_gates (source: gate runner) window: per cycle
  - `policy_exception_count` = count(open policy exceptions) (source: policy_exceptions.md) window: per cycle

- **Digest**: `/frameworks/release-mgmt/digests/YYYYMMDD-digest.md`
  - TL;DR (go/no-go), gates status, KPI snapshot, top gaps/exceptions, actionable notes, `snapshot_rev`, manifest hash.

#### 8) Acceptance Criteria (binary, testable)
- `schema_lint`: PASS for `release_plan.yaml` and manifest; common headers present.
- `item_mapping_parity ≥ 0.95` AND `critical_item_coverage = 1.0` AND `rollback_coverage = 1.0`.
- `handoff_manifest.yaml` present; all checksums computed.
- Single `snapshot_rev` across all artifacts in the handoff.
- `Critical=0` OR approved exception with valid expiry.
- Digest published at expected path for the cycle.

#### 9) Risks & Mitigations (3–5, concrete)
- Risk: Late-added items create unmapped gaps → Mitigation: gap alert section + block handoff for P0 gaps.
- Risk: Inconsistent governance tags across streams → Mitigation: governance tag validator before parity calc.
- Risk: Rollback not viable for infra changes → Mitigation: require rollback_ref runbook and DR drill evidence.
- Risk: Hidden dependencies between items → Mitigation: dependency graph in `release_plan.yaml` + sequencing check.

#### 10) Timeline & Next Steps (earliest checkpoint artifact)
- Day 0.5: Draft `release_plan.yaml` + schema PASS → emit `PLANNED`.
- Day 1.0: Build cross_stream_map + parity calc + digest v1.
- Day 1.5: Seal manifest + `READY_FOR_HANDOFF` → `PACKAGED`.
- Blocking Q: default parity threshold assumed 0.95 for overall; confirm with governance.